;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;   Modular Simulator Controller System - Standings Computations          ;;;
;;;                                                                         ;;;
;;;   Author:     Oliver Juwig (TheBigO)                                    ;;;
;;;   License:    (2022) Creative Commons - BY-NC-SA                        ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;-------------------------------------------------------------------------;;;
;;;                            Rule Include Section                         ;;;
;;;-------------------------------------------------------------------------;;;

#Include %kResourcesDirectory%Rules\Lap Information Retrieval.rules
#Include %kResourcesDirectory%Rules\Car Information Retrieval.rules


;;;-------------------------------------------------------------------------;;;
;;;                            Public Rules Section                         ;;;
;;;-------------------------------------------------------------------------;;;

priority: 5, {Any: [?Lap], [?Sector], [?Standings]} =>
		(Clear: Position.Standings.Ahead.Car), (Clear: Position.Standings.Ahead.Distance), (Clear: Position.Standings.Ahead.Delta),
		(Clear: Position.Standings.Behind.Car), (Clear: Position.Standings.Behind.Distance), (Clear: Position.Standings.Behind.Delta),
		(Clear: Position.Standings.Leader.Car), (Clear: Position.Standings.Leader.Distance), (Clear: Position.Standings.Leader.Delta),
		(Clear: Position.Track.Ahead.Car), (Clear: Position.Track.Ahead.Distance), (Clear: Position.Track.Ahead.Delta),
		(Clear: Position.Track.Behind.Car), (Clear: Position.Track.Behind.Distance), (Clear: Position.Track.Behind.Delta)
[?Lap] => (Prove: updateGrid(?Lap))
{Any: [?Lap], [?Sector], [?Standings]} => (Prove: updatePositions(!Lap))
priority: -5, [?Sector] => (Clear: Sector)
priority: -5, [?Standings] => (Clear: Standings)
							  
updateGrid(?lap) <= Set(Standings.Lap, ?lap, Weather, !Weather.Weather.Now),
					Call(builtin0, getTime, ?time), Set(Standings.Lap, ?lap, Time, ?time),
					Set(Standings.Lap, ?lap, Car.Count, !Car.Count), updateGrid(?lap, !Car.Count)

updateGrid(?, ?car) <= =<(?car, 0), !
updateGrid(?lap, ?car) <= carDriverForname(?car, ?forname), carDriverSurname(?car, ?surname),
						  carDriverNickname(?car, ?nickname), carNumber(?car, ?carNumber),
						  Append(Standings.Lap., ?lap, .Car., ?car, ?prefix),
						  Set(?prefix, Nr, ?carNumber), Set(?prefix, Driver.Forname, ?forname),
						  Set(?prefix, Driver.Surname, ?surname), Set(?prefix, Driver.Nickname, ?nickname),
						  ?nextCar = ?car - 1, updateGrid(?lap, ?nextCar)

updatePositions(?lap) <= carLaps(!Driver.Car, FULL, ?driverLaps), carLaps(!Driver.Car, RUNNING, ?driverRunning),
						 updatePositions(?lap, !Car.Count, ?driverLaps, ?driverRunning)

updatePositions(?, ?car, ?, ?) <= =<(?car, 0), !
updatePositions(?lap, !Driver.Car, ?driverLaps, ?driverRunning) <=
		carLapTime(!Driver.Car, ?lapTime), carPosition(!Driver.Car, ?position),
		Set(Position, ?position), Set(Standings.Lap, ?lap, Position, ?position),
		Append(Standings.Lap., ?lap, .Car., !Driver.Car, ?prefix),
		Set(?prefix, Time, ?lapTime), Set(?prefix, Delta, 0), Set(?prefix, Laps, ?driverLaps), Set(?prefix, Position, ?position),
		?nextCar = !Driver.Car - 1, updatePositions(?lap, ?nextCar, ?driverLaps, ?driverRunning), !
updatePositions(?lap, ?car, ?driverLaps, ?driverRunning) <=
		carLapTime(?car, ?carLapTime), lapTime(?lap, ?lapTime), carPosition(?car, ?position),
		carLaps(?car, FULL, ?carLaps), carLaps(?car, RUNNING, ?carRunning),  
		?standingsDistance = ?carLaps - ?driverLaps, ?standingsDelta = ?lapTime * ?standingsDistance,
		Append(Standings.Lap., ?lap, .Car., ?car, ?prefix),
		Set(?prefix, Time, ?carLapTime), Set(?prefix, Delta, ?standingsDelta), Set(?prefix, Laps, ?carLaps), Set(?prefix, Position, ?position),
		updateStandingsAhead(?lap, ?car, ?standingsDistance, ?standingsDelta),
		updateStandingsBehind(?lap, ?car, ?standingsDistance, ?standingsDelta),
		updateStandingsLeader(?lap, ?car, ?standingsDistance, ?standingsDelta),
		?trackDistance = ?driverRunning - ?carRunning, ?temp = ?lapTime * ?trackDistance, ?trackDelta = ?temp * -1,
		updateTrackAhead(?lap, ?car, ?trackDistance, ?trackDelta), updateTrackBehind(?lap, ?car, ?trackDistance, ?trackDelta),	
		?nextCar = ?car - 1, updatePositions(?lap, ?nextCar, ?driverLaps, ?driverRunning), !
updatePositions(?lap, ?car, ?driverLaps, ?driverRunning) <= ?nextCar = ?car - 1, updatePositions(?lap, ?nextCar, ?driverLaps, ?driverRunning)

updateStandingsAhead(?, ?car, ?distance, ?delta) <= ?delta > 0, unbound?(!Position.Standings.Ahead.Car), !,
													Set(Position.Standings.Ahead.Car, ?car), Set(Position.Standings.Ahead.Distance, ?distance),
													Set(Position.Standings.Ahead.Delta, ?delta)
updateStandingsAhead(?, ?car, ?distance, ?delta) <= ?delta > 0, Get(Position.Standings.Ahead.Delta, ?curDelta), ?delta < ?curDelta,
													Set(Position.Standings.Ahead.Car, ?car), Set(Position.Standings.Ahead.Distance, ?distance),
													Set(Position.Standings.Ahead.Delta, ?delta)
updateStandingsAhead(?, ?, ?, ?)

updateStandingsBehind(?, ?car, ?distance, ?delta) <= ?delta < 0, unbound?(!Position.Standings.Behind.Car), !,
													 Set(Position.Standings.Behind.Car, ?car),
													 Set(Position.Standings.Behind.Distance, ?distance),
													 Set(Position.Standings.Behind.Delta, ?delta)
updateStandingsBehind(?, ?car, ?distance, ?delta) <= ?delta < 0, Get(Position.Standings.Behind.Delta, ?curDelta), ?delta > ?curDelta,
													 Set(Position.Standings.Behind.Car, ?car),
													 Set(Position.Standings.Behind.Distance, ?distance),
													 Set(Position.Standings.Behind.Delta, ?delta)
updateStandingsBehind(?, ?, ?, ?)

updateStandingsLeader(?, ?car, ?distance, ?delta) <= carPosition(?car, 1), !, Set(Position.Standings.Leader.Car, ?car),
													 Set(Position.Standings.Leader.Distance, ?distance),
													 Set(Position.Standings.Leader.Delta, ?delta)
updateStandingsLeader(?, ?, ?, ?)
						
updateTrackAhead(?, ?car, ?distance, ?delta) <= ?distance < 0, unbound?(!Position.Track.Ahead.Car), !, Set(Position.Track.Ahead.Car, ?car),
												Set(Position.Track.Ahead.Distance, ?distance), Set(Position.Track.Ahead.Delta, ?delta)
updateTrackAhead(?, ?car, ?distance, ?delta) <= ?distance < 0, Get(Position.Track.Ahead.Distance, ?curDistance), ?distance > ?curDistance,
												Set(Position.Track.Ahead.Car, ?car), Set(Position.Track.Ahead.Distance, ?distance),
												Set(Position.Track.Ahead.Delta, ?delta)
updateTrackAhead(?, ?, ?, ?)

updateTrackAhead(?) <= Call(msgbox, Oops), bound?(!Position.Track.Ahead.Car), !
updateTrackAhead(?lap) <= carLaps(!Driver.Car, RUNNING, ?temp), ?running = 1 - ?temp, updateTrackAhead(?lap, ?running, !Car.Count)

updateTrackAhead(?, ?, ?car) <= =<(?car, 0), !
updateTrackAhead(?lap, ?running, !Driver.Car) <= ?nextCar = !Driver.Car - 1, updateTrackAhead(?lap, ?running, ?nextCar), !
updateTrackAhead(?lap, ?running, ?car) <= unbound?(!Position.Track.Ahead.Car), carLaps(?car, RUNNING, ?carRunning), lapTime(?lap, ?lapTime),
										  ?temp = ?carRunning + ?running, ?delta = ?lapTime * ?temp, ?distance = ?temp * -1,
										  Set(Position.Track.Ahead.Car, ?car), Set(Position.Track.Ahead.Distance, ?distance),
										  Set(Position.Track.Ahead.Delta, ?delta),
										  ?nextCar = ?car - 1, updateTrackAhead(?lap, ?running, ?nextCar), !
updateTrackAhead(?lap, ?running, ?car) <= carLaps(?car, RUNNING, ?carRunning), lapTime(?lap, ?lapTime),
										  ?temp = ?carRunning + ?running, ?delta = ?lapTime * ?temp, ?distance = ?temp * -1,
										  Get(Position.Track.Ahead.Distance, ?curDistance), ?distance > ?curDistance,
										  Set(Position.Track.Ahead.Car, ?car), Set(Position.Track.Ahead.Distance, ?distance),
										  Set(Position.Track.Ahead.Delta, ?delta),
										  ?nextCar = ?car - 1, updateTrackAhead(?lap, ?running, ?nextCar)

updateTrackBehind(?, ?car, ?distance, ?delta) <= ?distance > 0, unbound?(!Position.Track.Behind.Car), !, Set(Position.Track.Behind.Car, ?car),
												 Set(Position.Track.Behind.Distance, ?distance), Set(Position.Track.Behind.Delta, ?delta)
updateTrackBehind(?, ?car, ?distance, ?delta) <= ?distance > 0, Get(Position.Track.Behind.Distance, ?curDistance), ?distance < ?curDistance,
												 Set(Position.Track.Behind.Car, ?car), Set(Position.Track.Behind.Distance, ?distance),
												 Set(Position.Track.Behind.Delta, ?delta)
updateTrackBehind(?, ?, ?, ?)

updateTrackBehind(?) <= Call(msgbox, Oops), bound?(!Position.Track.Behind.Car), !
updateTrackBehind(?lap) <= carLaps(!Driver.Car, RUNNING, ?running), updateTrackBehind(?lap, ?running, !Car.Count)

updateTrackBehind(?, ?, ?car) <= =<(?car, 0), !
updateTrackBehind(?lap, ?running, !Driver.Car) <= ?nextCar = !Driver.Car - 1, updateTrackBehind(?lap, ?running, ?nextCar), !
updateTrackBehind(?lap, ?running, ?car) <= unbound?(!Position.Track.Behind.Car), carLaps(?car, RUNNING, ?carRunning),
										   lapTime(?lap, ?lapTime), ?temp = 1 - ?carRunning, ?distance = ?temp + ?running,
										   ?temp2 = ?distance * -1, ?delta = ?lapTime * ?temp2, Set(Position.Track.Behind.Car, ?car),
										   Set(Position.Track.Behind.Distance, ?distance), Set(Position.Track.Behind.Delta, ?delta),
										   ?nextCar = ?car - 1, updateTrackBehind(?lap, ?running, ?nextCar), !
updateTrackBehind(?lap, ?running, ?car) <= carLaps(?car, RUNNING, ?carRunning), lapTime(?lap, ?lapTime),
										   ?temp = 1 - ?carRunning, ?distance = ?temp + ?running,
										   Get(Position.Track.Behind.Distance, ?curDistance), ?distance < ?curDistance,
										   Set(Position.Track.Behind.Car, ?car), Set(Position.Track.Behind.Distance, ?distance),
										   ?temp2 = ?distance * -1, ?delta = ?lapTime * ?temp2, Set(Position.Track.Behind.Delta, ?delta),
										   ?nextCar = ?car - 1, updateTrackBehind(?lap, ?running, ?nextCar)
